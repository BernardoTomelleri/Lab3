\documentclass[10pt, a4paper, italian]{article}
\input{../../latex/preamble}
\input{../../latex/math}
\usepackage{multicol}
\geometry{left=2cm, right=2cm, top=2cm, bottom=2cm}

% indexes subsections with letters, sections with numbers (1.a, 1.b, ...)
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}

% lets graphicx know path where figures to be included are found
\graphicspath{{../figs/}}

\author{Gruppo 1.AC \\ Matteo Rossi, Bernardo Tomelleri}
\title{EsD2: Costruzione di D-Latch, contatori e shift-register}
\begin{document}
\date{\today}
\maketitle

\section{Misura componenti dei circuiti}
Riportiamo per completezza il valore della tensione continua di
alimentazione per i circuiti integrati misurata con il multimetro
\[
V_{CC} = 4.99 \pm 0.03 \si{\V}
\]

e il valore di capacità del condensatore di disaccoppiamento che collega le
linee di alimentazione a massa (sempre misurato con il multimetro)
\[
C_d = 97 \pm 4 \; \si{n\F}
\]

%=======================
\section{D-Latch con Enable}\label{sec: dlatch}
\subsection{Costruzione del circuito}
Si è costruito un circuito D-Latch secondo lo schema mostrato in
\cref{schm: dlatch} utilizzando le porte NAND di due integrati SN74LS00.
\begin{figure}
\centering
\begin{circuitikz}
    \draw (0,2.4) node[american nand port,label=north:R] (mynand1){};
    \draw (0,0) node[american nand port,label=south:S] (mynand2){};
    \draw (2.5,2.4) node[american nand port] (mynand3){};
    \draw (2.5,0) node[american nand port] (mynand4){};
    \draw (-3.5,0.5) node[american nand port,label=left:$\bar{D}$ NOT,
    rotate = 270] (mynand5){};
    \draw (-2,1.2) node[circ, label=left:$E$](E){}; 

	\draw (mynand3.out) to[short] ++(0,-1) to[short] ++(-2,0) |- (mynand4.in 1);
	\draw (mynand4.out) -- ++(1,0) node[circ, label=right:$\overline{Q}$]{};
	\draw (mynand3.out) -- ++(1,0) node[circ, label=right:$Q$]{};
	\draw (mynand4.out) to[short] ++(0,1) to[short] ++(-1.8,0) |- (mynand3.in 2);
    \draw (mynand1.out) |- (mynand3.in 1);
    \draw (mynand2.out) |- (mynand4.in 2);
    \draw (mynand5.in 1) |- (mynand5.in 2);
    \draw (mynand5.in 2) |- (mynand1.in 1);
    \draw (mynand1.in 1) -- ++ (-3,0) node[circ, label=left:$D$]{};
    \draw (mynand5.out) |- (mynand2.in 2);
    \draw (mynand2.in 1) |- (E);
    \draw (mynand1.in 2) |- (E);
\end{circuitikz}
\caption{Schema logico del circuito $D$-Latch (con Enable) realizzato
\label{schm: dlatch}}
\end{figure}

Per studiarne il comportamento generiamo nei due pin DIO 0 (DATA) e DIO 1
(ENABLE) dell'AD2 due segnali di clock di frequenza $f = \SI{1}{k\hertz}$ e
sfasati tra loro di $\SI{90}{\degree}$ agli ingressi $D$ ed $E$ del
circuito. 

\subsection{Analisi del funzionamento del circuito}
Il circuito è composto da un Latch $RS$ i cui ingressi sono collegati a due
porte NAND, di cui un ingresso per ciascuna è collegato all'input $E$, mentre
gli altri due ingressi sono collegati l'uno al segnale opposto dell'altro
tramite una porta NOT (in figura la porta NAND più in alto tra le due $(R)$ è
collegata all'input $D$, mentre quella più in basso $(S)$ a $\overline{D}$).

L'equazione fondamentale del circuito è quindi data dalla
\begin{equation}
Q(t + \Delta t) = \overline{\overline(D \cdot E)} +
\overline{(\overline{D} \cdot E)} \cdot Q(t) =
E \cdot D + \overline{E} \cdot Q(t)
\end{equation}
da cui si può ricavare la corrispondente tabella di verità
\begin{table}
\begin{center}
    \begin{tabular}{cccc}
      \toprule
      $E$ & $D$     & $Q(t)$  & $ Q(t + \Delta t)$ \\
      \midrule
      \midrule
      0     & X & 0         & 0 \\
      0     & X & 1         & 1 \\
      1     & 0         & X & 0 \\
      1     & 1         & X & 1 \\
      \bottomrule
    \end{tabular}
\end{center}
\caption{Tabella di verità del circuito $D$-Latch con Enable (con X si indica
valore logico indefinito/don't care) \label{tab: dlatch}}
\end{table}

Come si può vedere dalla tabella di verità (\cref{tab: dlatch}) l'uscita $Q$
funge da memoria a un bit se $E$ è al livello logico basso (stato di HOLD),
mentre assume il valore logico dell'input $D$ quando il segnale di ENABLE è
acceso.
Questo rende il valore dell'uscita indipendente dalle caratteristiche
temporali delle porte NAND e protegge il circuito dallo stato proibito di
oscillazione/racing $R = S = 1$ da cui è affetto il semplice $RS$-Latch.

\subsection{Verifica della tabella di verità del Latch}
Per conferma del corretto funzionamento del Latch possiamo confrontare
le uscite ottenute da un'acquisizione con Logic Analyzer con i valori
riportati in \cref{tab: dlatch} inviando all'ingresso del circuito con
Patterns due segnali di clock, di modo che $E$ sia lo stesso segnale in $D$,
a cui si è però aggiunta una fase $\phi = \pm \SI{90}{\degree}$.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{dlatch}
    \caption{Acquisizione di un ciclo completo (frequenza 1 kHz) con Logic
    Analyzer dei segnali in ingresso ($D =$ DIO 0, $E =$ DIO 1) e in uscita
    ($Q =$ DIO 2, $\overline{Q} =$ DIO 3) dal D-Latch.
    \label{fig: dlatch}}
\end{figure}
\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{latch2}
	\caption{Acquisizione con Logic dell'andamento temporale dei segnali in
	ingresso uscita dal D-Latch per $\phi = -\SI{90}{\degree}$.
	\label{fig: Log_DLATCH2}}
\end{figure}

Dalle \cref{fig: dlatch} e \cref{fig: Log_DLATCH2} si osserva come durante lo
stato basso di Enable il segnale in uscita rimanga costante rispetto a
variazioni del segnale in $D$, mentre quando
$E = 1 \implies Q(t + \Delta t) = D$ coerentemente con quanto previsto dalla
tabella di verità e come principio di funzionamento della memoria a 1 bit.

\subsection{Misura dei tempi di propagazione nelle transizioni di stato}
Si riescono a distinguere due diverse transizioni dei segnali in ingresso per
ciascun valore di sfasamento tra i due segnali di clock in $D$ ed $E$;
per $\phi = \SI{90}{\degree}$:
\begin{enumerate}
\item $D \coloneqq 0$, $E: 0 \to 1$ \label{item: Efall}
\item $D: 0 \to 1$, $E \coloneqq 1$. \label{item: Drise}

Mentre per $\phi = - \SI{90}{\degree} = 270 \; \si{\degree}$:
\item $D: 1 \to 0$, $E \coloneqq 1$ \label{item: Dfall}
\item $D \coloneqq 1$, $E: 0 \to 1$. \label{item: Erise}
\end{enumerate}

Si sono misurati i ritardi tra la transizione dei segnali in ingresso e i
corrispondenti cambiamenti di stato in uscita su scala dei tempi minima
($\SI{10}{n\s}$) con i cursori dalle acquisizioni con Logic Analyzer e per
riconferma anche con l'oscilloscopio da banco (a cui associamo come
incertezza il contributo dato dalle specifiche del datasheet, tenendo conto
dell'instabilità e dello spessore delle tracce sullo schermo). Riportiamo
di seguito e nella \cref{fig: Drise}, \cref{fig: Drise_osc}, \cref{fig: Dfall}
e \cref{fig: Erise} i risultati ottenuti.
\begin{enumerate}
\item $t_{PHL} = 30 \pm 10 \; \si{n\s}$
\item $t_{PLH} = 20 \pm 10 \; \si{n\s}$

\item $t_{PHL} = 40 \pm 10 \; \si{n\s}$
\item $t_{PLH} = 30 \pm 10 \; \si{n\s}$
\end{enumerate}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{dlatch_Drise}
    \caption{Acquisizione del Logic Analyzer durante la transizione
    \ref{item: Drise} del D-Latch \label{fig: Drise}}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{dlatch_Drise}
    \caption{Acquisizione da oscilloscopio digitale della transizione
    \ref{item: Drise} del D-Latch \label{fig: Drise_osc}}
    \includegraphics[width=\textwidth]{dlatch_Dfall40}
    \caption{Acquisizione del Logic Analyzer durante la transizione
    \ref{item: Dfall} del D-Latch \label{fig: Dfall}}
    \includegraphics[width=\textwidth]{dlatch_Erise}
    \caption{Acquisizione del Logic Analyzer durante la transizione
    \ref{item: Erise} del D-Latch \label{fig: Erise}}
\end{figure}

Il massimo ritardo indotto si è trovato in corrispondenza della transizione
\ref{item: Dfall} dell'input $D$ da alto a basso (con i cursori
dell'oscilloscopio $t_{PHL} = 35 \pm 2 \; \si{n\s}$) mentre il minimo per la
\ref{item: Drise} (con oscilloscopio $t_{PLH} = 11 \pm 1 \; \si{n\s}$).

Dalle specifiche del DS si trova che i tempi di propagazione tipici e massimi
per una singola porta NAND sono:
\begin{table}[htbp]
\centering
\begin{tabular}{cccc}
	& typ & max & [units] \\
    $t\ped{PLH}$ & $11$ & $22$ & \si{n\s} \\
    $t\ped{PHL}$ & $7$ & $15$ & \si{n\s}
\end{tabular}
\end{table}
da cui vediamo che le nostre misure dei ritardi accumulati tra uscita e
ingresso del circuito sono compatibili con i tempi necessari per il numero di
porte NAND che devono commutare per il cambiamento di stato del D-Latch.

%=======================
\section{Shift-register con edge-triggered D-Flip Flop}
\subsection{Costruzione del circuito}
Si vuole ora costruire uno Shift Register a 4 bit a partire da due integrati
della serie SN74LS74 (Dual Positive-Edge-Triggered Flip-Flops), secondo lo
schema riportato in \cref{fig: schem_shift} e verificarne il funzionamento.
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{schem_shift}
	\caption{\label{fig: schem_shift}}
\end{figure}

\subsection{Verifica della sincronia delle uscite rispetto a PRESET}
Una volta controllato che le uscite $Q_0$, $Q_1$, $Q_2$ e $Q_4$ fossero nello
stato $0000$, abbiamo utilizzato la funzione StaticIO per pilotare il PRESET
(ingresso PRE-BUTTON di \cref{fig: schem_shift}) tramite un pulsante inverso
(di tipo pressed$ = 0$ e released$ = 1$).
Dunque si è acquisito con Logic Analyzer l'andamento temporale dei 4 segnali
in uscita con condizione di trigger coincidente alla pressione del pulsante.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.trans}
	\caption{Acquisizione con Logic dei segnali in PRE-BUTTON le 4 uscite dal
	registro a scorrimento pilotato dall'ingresso di PRESET
	\label{fig: Shift_reg_trans}}
\end{figure}

Dalla \cref{fig: Shift_reg_trans} vediamo che le commutazioni delle
uscite avvengono allo stesso tempo, dopo un $\Delta t = 40 \si{n\s}$ a partire
dalla pressione del pulsante di preset le 4 uscite raggiungono lo stato $1111$.

Nella \cref{fig: reg_presync} si mette in evidenza come questo cambiamento di
stato avvenga indipendentemente dal segnale di clock in ingresso ai FF, da cui
si vede che l'ingresso di PRESET dei Flip-Flop è asincrono come atteso dalle
specifiche tecniche.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.b}
	\caption{Acquisizione con Logic dei segnali in PRE-BUTTON, CLOCK e
	$Q_{0, \ldots, 3}$ in uscita dal registro a scorrimento studiato
	\label{fig: reg_presync}}
\end{figure}

\subsection{Verifica del funzionamento tramite clock}\label{sbs: clock_reg}
Possiamo costruire una tabella di verità per il registro in funzione del tempo
(discreto) battuto dal periodo $T$ del clock:
\begin{table}[htbp]
\centering
\begin{tabular}{c|c}
\toprule
$Q_i(t = t')$ & $Q_i(t = t' + T)$\\
\midrule
\midrule
$Q_0$ & $Q_0'$ \\
$Q_1$ & $Q_0(t=t')$ \\
$Q_2$ & $Q_1(t=t') = Q_0(t = t' - T)$ \\
$Q_3$ & $Q_2(t=t') = Q_0(t = t'- 2T)$ \\
\bottomrule
\end{tabular}
\caption{Tabella "di verità" di un registro a scorrimento, in cui $Q_0'$ è il
valore che viene inviato durante il fronte di salita $t'$ del clock tramite
il $D$-SWITCH
\label{tab: S-register}}
\end{table}

Nel caso in cui il pulsante di PRESET inizializzi tutte le uscite a 1, e il
D-Switch sia impostato (sempre con StaticIO) al valore $Q_0' = 0$, la
\cref{tab: S-register} si traduce nelle commutazioni di stato previste dalla
\cref{tab: s-reg-truth}
\begin{table}[htbp]
	\centering
	\begin{tabular}{c|cccc}
	\toprule
	$t$	  &		$Q_0$	&	$Q_1$	& $Q_2$	&	$Q_3$  \\
	\midrule
	\midrule
		$t'$ 	&	$1$	&	$1$	&	$1$	&	$1$	\\
		$+T$	&	$0$	&	$1$	&	$1$	&	$1$	\\
		$+2T$	&	$0$	&	$0$	&	$1$	&	$1$	\\
		$+3T$	&	$0$	&	$0$	&	$0$	&	$1$	\\
		$+4T$	&	$0$	&	$0$	&	$0$	&	$0$	\\		
	\bottomrule
	\end{tabular}
\caption{Sequenza di transizioni che si osservano a partire da quando viene
premuto il pulsante di PRESET ($t'$) lasciando a livello basso il $D$-SWITCH
del registro a scorrimento. \label{tab: s-reg-truth}}
\end{table}

Per verificare il corretto funzionamento del circuito si pilota il registro
con un segnale di clock di frequenza $f = \SI{1}{\Hz}$ e si fa ancora uso di
Logic per acquisire gli andamenti nel tempo dei valori assunti dalle uscite.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.c}
	\caption{Acquisizione con Logic dei segnali in uscita da un registro a
	scorrimento di 4 bit come illustrato in \cref{sbs: clock_reg}
	\label{fig: Shift_reg_clock}}
\end{figure}
Dalla \cref{fig: Shift_reg_clock} si verifica come atteso che dopo 3 periodi
di clock (3 secondi) a partire da quando l'uscita $Q_0 = 0$, le 4 uscite
diventano (e si mantengono costanti nel tempo visto che il D-Switch rimane
fisso a 0) tutte quante basse.

Da questo si intuisce che collegando l'uscita (NOT) $Q_3$ all'ingresso
$D$-switch, possiamo generare una sequenza periodica/costruire un contatore
con modulo.

\subsection{Prevalenza tra gli ingressi D-switch e PRESET}
Utilizzando allo stesso tempo gli ingressi $D$-switch e PRESET del registro
si vede che è l'ultimo a pilotare il segnale in uscita, dal momento che PRESET
è asincrono (indipendente dalla salita del clock). Questo risulta consistente
con la regola generale per cui le architetture asincrone prendono la precedenza
sulle istruzioni sincrone. 

\subsection{Twisted-ring Johnson counter}
Dopo aver reimpostato il registro nello stato $Q_{i=0,\ldots, 3} = 0$, si
collega l'uscita $\overline{Q_3}$ all'ingresso $D$ del primo Flip-Flop e si
invia un clock di frequenza pari $f = \SI{1}{k\Hz}$ all'ingresso del circuito.

Ci si aspetta che, prendendo un'uscita a caso, si osservi un segnale di clock di frequenza un quarto di quella di clock: questo effetto è dovuto a come la sequenza viene caricata nel registro a partire dall'uscita $\overline{Q_3}$.
In generale supponendo che nel circuito ci siano in cascata n Flip-Flop, e che tutte le uscite siano inizializzate a 0, in una qualsiasi delle uscite otterrò un clock di frequenza pari a $\frac{f\ped{clk}}{n}$.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.e}
	\caption{Acquisizione temporale con Logic dei segnali in uscita da un registro a scorrimento di 4 bit con l'ultima uscita negata collegata all'entrata del primo flip flop
	\label{fig: Shift_reg_seq}}
\end{figure}

%=======================
\section{Generatore di sequenze pseudo-casuali}
\subsection{Costruzione del circuito}
Si vuole ora costruire un generatore di sequenze pseudo-casuali a 4 bit utilizzando lo shift register costruito in precedenza e una porta XOR; la schematica del circuito che utilizzeremo è riportato in figura \cref{fig: schem_gen}.
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{schem_gen}
	\captionof{figure}{\label{fig: schem_gen}}
\end{figure}

\subsection{Analisi e verifica del funzionamento}
Dopo aver montato il circuito si inizializzano tutti Flip-Flop a 1 e si invia un segnale di clock a 10 kHz per verificare il funzionamento: 
essendo il registro di lunghezza pari a 4 bit, dalla teoria ci aspettiamo che la sequenza si ripeta dopo $2^4 = 16$ eventi al massimo, condizione che si ottiene utilizzando come TAP (segnali in ingresso alla porta XOR, la cui uscita sarà inviata all'entrata D del primo Flip-Flop) le uscite $Q_2$ e $Q_3$. 

\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b}
	\caption{\label{fig: TAP_23}Acquisizione temporale con Logic del bus in uscita dal generatore di sequenze psudo-casuale descritto in \cref{fig: schem_gen}}
\end{figure}

Dalla \cref{fig: TAP_23} si verificano le aspettative per cui la sequenza generata a una qualsiasi uscita si ripete ogni 16 periodi di clock (essendo uno shift register la sequenza nelle altre uscite sarà la medesima, solo che saranno sfasate lungo l'asse temporale le une con le altre).
\subsection{Studio delle sequenze generabili con diverse condizioni iniziali}
Si provano quindi altre combinazioni di TAP, per verificare che la scelta di utilizzare l'uscita $Q_2$ e $Q_3$ produce una sequenza più lunga rispetto a qualunque altra configurazione
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b_10}
	\caption{Acquisizione temporale con Logic del bus in uscita dal generatore di sequenze psudo-casuale con TAP sulle uscite $Q_0$ e $Q_1$, la sequenza si ripete ogni 4 eventi
	\label{fig: TAP_10}}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b_21}
	\caption{Acquisizione temporale con Logic del bus in uscita dal generatore di sequenze psudo-casuale con TAP sulle uscite $Q_2$ e $Q_1$, la sequenza si ripete ogni 8 eventi
	\label{fig: TAP_21}}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b_30}
	\caption{Acquisizione temporale con Logic del bus in uscita dal generatore di sequenze pseudo-casuale con TAP sulle uscite $Q_0$ e $Q_3$, la sequenza si ripete ogni 16 eventi \label{fig: TAP_30}}
\end{figure}

%=======================
\section{Divisori di frequenza con contatori binari}
\subsection{Costruzione del circuito}
Si intende costruire un divisore di frequenza a partire da un contatore binario a 4 bit, utilizzando l'integrato SN74LS163, presente in \cref{fig: schem_counter}. Si vuole innanzitutto verificarne il funzionamento. 
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{schem_con}
	\caption{\label{fig: schem_counter}}
\end{figure}

\subsection{Verifica del ciclo di funzionamento dei contatori}
\label{sec: count_base}
Dopo aver montato il circuito utilizziamo la funzione Pattern di Waveform per inviare un segnale di clock di frequenza pari a 10 kHz al pin di clock (CLK) del contatore, e utilizzeremo Logic per acquisire le uscite $Q_0$->$Q_3$.
Essendo un contatore a 4 bit, ci si aspetta che il Bus conti dallo stato 0000 (0 in decimale) fino allo stato 1111 (15 in decimale) in ordine crescente.
Per questo motivo utilizzeremo un formato di Bus esadecimale per verificare che il circuito generi tutti gli stati possibili (0->F).
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.b}
	\caption{Acquisizione temporale con Logic del bus in uscita dal contatore, con frequenza di clock pari a 10 kHz \label{fig: Count_Clock}}
\end{figure}
Dalla \cref{fig: Count_Clock} si può notare che il comportamento del circuito è come atteso, e che gli stati del bus in uscita comprendono tutti i valori in ordine crescente della numerazione esadecimale 
\subsection{Verifica della divisione in frequenza}

Dato che il contatore binario incrementa di 1 ad ogni evento di clock, il bit di ordine n avrà come frequenza la metà di quella del bit di ordine n-1.
Avendo noi un BUS composto da 4 bit, ci si aspetta quindi che le frequenze ottenute siano $\frac{f_{clock}}{2}$ (per il LSB),$\frac{f_{clock}}{4}$,$\frac{f_{clock}}{8}$ e $\frac{f_{clock}}{16}$ (per il MSB).
Sempre facendo riferimento all  \cref{fig: Count_Clock} si può notare come le uscite del contatore si comportino da divisori in frequenza: infatti i periodi che si trovano analizzando l'acquisizione sono 2 (LSB), 4, 8 e 16 (MSB) volte il periodo del clock.
\subsection{Transizione sincrona del contatore}
\label{sec: count_trans}
Utilizziamo la funzione di trigger di Logic e la impostiamo in modo tale che l'acquisizione cominci quando il segnale presente in $Q_3$ cambia da 1 a 0 in modo da poter studiare gli eventuali ritardi delle singole uscite nella transizione F->0 e verificare il comportamento sincrono del contatore.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.d}
	\caption{Acquisizione temporale con Logic del bus in uscita dal contatore durante la transizione 15->0; dall'immagine possiamo notare il comportamento sincrono della commutazione delle uscite del contatore \label{fig: Count_150}}
\end{figure}
Dalla \cref{fig: Count_150} possiamo infatti vedere che la transizione è sincrona e avviene con un ritardo di $30 \si{n\s}$ da quando il clock compie il salto 0->1; il passaggio di stato 1->0 avviene contemporaneamente in ogni uscita.
\subsection{Divisore di frequenza 1/10; Contatore BCD}
Si vuole quindi realizzare un divisore in frequenza, che generi un segnale di periodo pari a 10 volte quello di clock: per farlo utilizzeremo il pin CLEAR del contatore, il quale quando gli viene inviato un segnale Low resetta il contatore allo stato 0000.
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{Draft1}
	\caption{Schematica utilizzata per il divisore per 10 di frequenza
	\label{schem: 10_div}}
\end{figure}
È quindi necessario che il contatore conti un totale di 10 stati e poi si resetti, per cui partendo dallo 0, dobbiamo imporre la condizione che arrivati allo stato 9 (1001) il contatore riceva il comando di reset tramite Clear (che ricordiamo essere Active Low).
Per farlo utilizzeremo una porta NAND (utilizzando l'integrato SN74LS00) ai cui 2 ingressi invieremo il LSB e il MSB e invieremo l'uscita al pin di Clear. In questo modo, quando il contatore arriva a 9 il pin di Clear riceverà un segnale Low e il circuito si azzererà; pertanto la frequenza del segnale Clear sarà un decimo di quella di clock.
Inoltre essendo il segnale di Clear sullo stato Low solamente quando il bus in uscita registra lo stato 1001, mi aspetterò un Duty Cycle pari al $90 \percent$
Si costruisce quindi il circuito presente in \cref{schem: 10_div}.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.e}
	\caption{Acquisizione temporale con Logic del bus in uscita dal circuito che conta fino a 10; si può notare che il segnale in entrata nel pin Clear ha effettivamente periodo pari a 10 volte quello del clock \label{fig: Count_10th}}
\end{figure}
Come prima, si utilizza la funzione Logic per acquisire il Bus dei 4 bit in uscita, il clock e il bit di Clear.
Osservando l'acquisizione presente in \cref{fig: Count_10th}, possiamo concludere come da aspettative che il segnale presente su clear ha una frequenza pari a $\frac{f_{clock}}{10}$ e Duty Cycle pari al $90 \percent$.
\subsection{Divisore di frequenza programmabile con RCO}
Per concludere, si vuole costruire un divisore in frequenza programmabile:
per questo scopo utilizzeremo il bit RCO (Ripple Carry Output), la cui funzione è di generare un segnale H solo nel caso in cui il contatore abbia raggiunto lo stato massimo (1111) e il bit Load, che invece quando vale 0 sovrascrive lo stato del contatore in quello presente all'interno del bus di input. 
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{Draft2}
	\label{schem: programmable_counter}
	\caption{Schematica utilizzata per il divisore di frequenza programmabile}
\end{figure}
Vogliamo intanto verificare il funzionamento del RCO; dopo aver montato nuovamento il circuito presente in \cref{fig: schem_counter} inviamo un segnale di clock di frequenza 10 kHz e utilizziamo Logic per acquisire i segnali del bus dei 4 bit di output e il segnale di RCO in funzione del tempo.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.RCO}
	\label{fig: RCO_f}
	\caption{Acquisizione con Logic dei segnali del contatore per verificare il funzionamento del bit RCO}
\end{figure}
Dalla \cref{fig: RCO_f} possiamo notare che il bit RCO funziona come da aspettative.
Si collega ora l'uscita dal RCO all'ingresso di una porta NOT dell'integrato SN74LS04; l'uscita di tale porta sarà inviata al pin LOAD del contatore, come schematizzato in \cref{schem: programmable_counter}.
Si utilizza la funzione StaticIO per inserire nel Bus di ingresso (A,B,C,D) lo stato 0101 e accendiamo il segnale di clock generato tramite Pattern a frequenza 10 kHz. 
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0101}
	\label{fig: c_0101}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0101}
\end{figure}
Dalla \cref{fig: c_0101} ci accorgiamo che quando il contatore riceve il segnale di LOAD, quindi quando si registra 1 nel bit RCO, la sequenza iniziale non viene immediatamente caricata, ma sarà rimandata di un evento di clock.
Di conseguenza, qualunque sia la sequenza iniziale del nostro circuito lo stato finale 1111 verrà sempre "contato".
\subsection{Misura dei tempi caratteristici del divisore RCO}
Si cambia ora la sequenza di inizializzazione a 0110, e utilizzando la funzione Logic impostiamo un trigger quando il bit LOAD compie la transizione 0->1: in seguito a quanto visto nella sezione precedente ci aspettiamo che il contatore passi dallo stato 1111 allo stato iniziale.
Utilizzeremo una scala dei tempi molto ristretta per verificare che quanto affermato nella \cref{sec: count_trans} sia ancora vero.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0110_20ns}
	\label{fig: count_Sounasegadicomechiamarlo}
	\caption{Acquisizione con logic dei segnali all'interno del circuito divisore di frequenza programmabile per un fondo scala dei tempi molto ristretto, con sequenza di avvio 0110}
\end{figure}
Dalla \cref{fig: count_Sounasegadicomechiamarlo} si può notare che è sempre presente un ritardo dall'inizio del nuovo Tick di clock alla commutazione delle uscite (che come prima è sincrona) che vale indicativamente $30 \si{n\s}$.
\subsection{Analisi e verifica del comportamento del divisore RCO}
Si passa infine a verificare la corrispondenza tra sequenza iniziale e la frequenza ottenuta.
In questa sezione utilizzeremo come frequenza quoziente quella del segnale in uscita dal RCO.
Analizzando il comportamento del circuito facendo uso di quanto visto nelle sezioni precedenti ci si aspetta che il periodo del segnale RCO sia pari a quello di clock moltiplicato per il numero di salti di stato necessari per farlo arrivare a 0000; chiamando A il valore in base 10 che corrisponde allo stato iniziale si ha dunque:
\begin{equation}
T_{divisore,A}=T_{clock} \times (16-A)
\end{equation}
Visto però il funzionamento dei pin LOAD e RCO, se utilizzassimo come sequenza iniziale 1111, il circuito produrrebbe un segnale costante: infatti 1111 è anche lo stato a cui avviene il caricamento della sequenza, che però risulta essere sempre la medesima, inducendo quindi uno stato incommutabile.
Programmando la sequenza con 0000 invece mi aspetto che il comportamento sia analogo a quello presente in \cref{sec: count_base} essendo 0000 lo stato iniziale a cui si resetta autonomamente il counter in assenza di segnali di LOAD.
Si provano quindi diverse sequenze iniziali per il circuito per cui ci si aspetta:
\begin{table}[htbp]
\centering
\begin{tabular}{c|c}
\toprule
$Seq. iniziale$ & $T_{RCO} [T_{clock}]$\\
\midrule
$0000$ & $16$ \\
$0010$ & $14$ \\
$0101$ & $11$ \\
$1110$ & $2$ \\
$1111$ & $0$ \\
\bottomrule
\end{tabular}
\end{table}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0000}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0000, da cui si misura $T= 16 T_{clock}$}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0010}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0010, da cui si misura $T= 14 T_{clock}$}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0101}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0101, da cui si misura $T= 11 T_{clock}$}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_1110}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 1110, da cui si misura $T= 2 T_{clock}$}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_1111}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 1111, dal quale si vede che RCO è un segnale costante}
\end{figure}
Dalle acquisizioni fatte con logic possiamo concludere che i periodi sono quelli aspettati.
%=======================
\section{Sintetizzatore musicale}
%TODO ? AMOGUSSSS AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
\iffalse
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣤⣤⣤⣤⣤⣶⣦⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡿⠛⠉⠙⠛⠛⠛⠛⠻⢿⣿⣷⣤⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⠋⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⠈⢻⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣸⣿⡏⠀⠀⠀⣠⣶⣾⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⠁⠀⠀⢰⣿⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣷⡄⠀
⠀⠀⣀⣤⣴⣶⣶⣿⡟⠀⠀⠀⢸⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣷⠀
⠀⢰⣿⡟⠋⠉⣹⣿⡇⠀⠀⠀⠘⣿⣿⣿⣿⣷⣦⣤⣤⣤⣶⣶⣶⣶⣿⣿⣿⠀
⠀⢸⣿⡇⠀⠀⣿⣿⡇⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠀
⠀⣸⣿⡇⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠉⠻⠿⣿⣿⣿⣿⡿⠿⠿⠛⢻⣿⡇⠀⠀
⠀⣿⣿⠁⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀
⠀⣿⣿⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀
⠀⣿⣿⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀
⠀⢿⣿⡆⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀
⠀⠸⣿⣧⡀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠃⠀⠀
⠀⠀⠛⢿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⣰⣿⣿⣷⣶⣶⣶⠶⠀⢠⣿⣿⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⣿⣿⡇⠀⣽⣿⡏⠁⠀ ⠀⢸⣿⡇⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⣿⣿⡇⠀⢹⣿⡆⠀⠀⠀ ⣸⣿⠇⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢿⣿⣦⣄⣀⣠⣴⣿⣿⠁⠀⠈⠻⣿⣿⣿⣿⡿⠏⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠛⠻⠿⠿⠿⠿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
\fi
%=======================
\section*{Conclusioni e commenti finali}
Si è riusciti a verificare il corretto funzionamento di circuiti logici
sequenziali di crescente complessità e svariate applicazioni (e.g.
crittografia, sistemi di controllo e misura) costruiti con porte NAND, XOR,
D-Latch e contatori sincroni.
In particolare sono stati realizzati e studiati un D-Latch, uno shift-register
con positive edge-triggered D-FF, un generatore di sequenze pseudocasuali e
alcuni tipi di divisore di frequenza con contatori binari.
Inoltre si è riusciti ad apprezzare l'effetto dei tempi di propagazione
delle porte sul loro comportamento, seppur in maniera limitata dalla bassa
risoluzione temporale dell'AD2.

%=======================
\section*{Dichiarazione}
I firmatari di questa relazione dichiarano che il contenuto della relazione \`e
originale, con misure effettuate dai membri del gruppo, e che tutti i firmatari
hanno contribuito alla elaborazione della relazione stessa.

\end{document}
