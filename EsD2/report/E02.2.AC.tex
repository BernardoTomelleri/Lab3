\documentclass[10pt, a4paper, italian]{article}
\input{../../latex/preamble}
\input{../../latex/math}
\usepackage{multicol}
\geometry{left=2cm, right=2cm, top=2cm, bottom=2cm}

% indexes subsections with letters, sections with numbers (1.a, 1.b, ...)
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}

% lets graphicx know path where figures to be included are found
\graphicspath{{../figs/}}

\author{Gruppo 1.AC \\ Matteo Rossi, Bernardo Tomelleri}
\title{EsD2: Costruzione di D-Latch, contatori e shift-register}
\begin{document}
\date{\today}
\maketitle

\section{Misura componenti dei circuiti}
Riportiamo per completezza il valore della tensione continua di
alimentazione per i circuiti integrati misurata con il multimetro
\[
V_{CC} = 4.99 \pm 0.03 \si{\V}
\]

e il valore di capacità del condensatore di disaccoppiamento che collega le
linee di alimentazione a massa (sempre misurato con il multimetro)
\[
C_d = 97 \pm 4 \; \si{n\F}
\]

%=======================
\section{D-Latch con Enable}\label{sec: dlatch}
\subsection{Costruzione del circuito}
Si è costruito un circuito D-Latch secondo lo schema mostrato in
\cref{schm: dlatch} utilizzando le porte NAND di due integrati SN74LS00.
\begin{figure}
\centering
\begin{circuitikz}
    \draw (0,2.4) node[american nand port,label=north:R] (mynand1){};
    \draw (0,0) node[american nand port,label=south:S] (mynand2){};
    \draw (2.5,2.4) node[american nand port] (mynand3){};
    \draw (2.5,0) node[american nand port] (mynand4){};
    \draw (-3.5,0.5) node[american nand port,label=left:$\bar{D}$ NOT,
    rotate = 270] (mynand5){};
    \draw (-2,1.2) node[circ, label=left:$E$](E){}; 

	\draw (mynand3.out) to[short] ++(0,-1) to[short] ++(-2,0) |- (mynand4.in 1);
	\draw (mynand4.out) -- ++(1,0) node[circ, label=right:$\overline{Q}$]{};
	\draw (mynand3.out) -- ++(1,0) node[circ, label=right:$Q$]{};
	\draw (mynand4.out) to[short] ++(0,1) to[short] ++(-1.8,0) |- (mynand3.in 2);
    \draw (mynand1.out) |- (mynand3.in 1);
    \draw (mynand2.out) |- (mynand4.in 2);
    \draw (mynand5.in 1) |- (mynand5.in 2);
    \draw (mynand5.in 2) |- (mynand1.in 1);
    \draw (mynand1.in 1) -- ++ (-3,0) node[circ, label=left:$D$]{};
    \draw (mynand5.out) |- (mynand2.in 2);
    \draw (mynand2.in 1) |- (E);
    \draw (mynand1.in 2) |- (E);
\end{circuitikz}
\caption{Schema logico del circuito $D$-Latch (con Enable) realizzato
\label{schm: dlatch}}
\end{figure}

Per studiarne il comportamento generiamo nei due pin DIO 0 (DATA) e DIO 1
(ENABLE) dell'AD2 due segnali di clock di frequenza $f = \SI{1}{k\hertz}$ e
sfasati tra loro di $\SI{90}{\degree}$ agli ingressi $D$ ed $E$ del
circuito. 

\subsection{Analisi del funzionamento del circuito}
Il circuito è composto da un Latch $RS$ i cui ingressi sono collegati a due
porte NAND, di cui un ingresso per ciascuna è collegato all'input $E$, mentre
gli altri due ingressi sono collegati l'uno al segnale opposto dell'altro
tramite una porta NOT (in figura la porta NAND più in alto tra le due $(R)$ è
collegata all'input $D$, mentre quella più in basso $(S)$ a $\overline{D}$).

L'equazione fondamentale del circuito è quindi data dalla
\begin{equation}
Q(t + \Delta t) = \overline{\overline(D \cdot E)} +
\overline{(\overline{D} \cdot E)} \cdot Q(t) =
E \cdot D + \overline{E} \cdot Q(t)
\end{equation}
da cui si può ricavare la corrispondente tabella di verità
\begin{table}
\begin{center}
    \begin{tabular}{cccc}
      \toprule
      $E$ & $D$     & $Q(t)$  & $ Q(t + \Delta t)$ \\
      \midrule
      \midrule
      0     & X & 0         & 0 \\
      0     & X & 1         & 1 \\
      1     & 0         & X & 0 \\
      1     & 1         & X & 1 \\
      \bottomrule
    \end{tabular}
\end{center}
\caption{Tabella di verità del circuito $D$-Latch con Enable (con X si indica
valore logico indefinito/don't care) \label{tab: dlatch}}
\end{table}

Come si può vedere dalla tabella di verità (\cref{tab: dlatch}) l'uscita $Q$
funge da memoria a un bit se $E$ è al livello logico basso (stato di HOLD),
mentre assume il valore logico dell'input $D$ quando il segnale di ENABLE è
acceso.
Questo rende il valore dell'uscita indipendente dalle caratteristiche
temporali delle porte NAND e protegge il circuito dallo stato proibito di
oscillazione/racing $R = S = 1$ da cui è affetto il semplice $RS$-Latch.

\subsection{Verifica della tabella di verità del Latch}
Per conferma del corretto funzionamento del Latch possiamo confrontare
le uscite ottenute da un'acquisizione con Logic Analyzer con i valori
riportati in \cref{tab: dlatch} inviando all'ingresso del circuito con
Patterns due segnali di clock, di modo che $E$ sia lo stesso segnale in $D$,
a cui si è però aggiunta una fase $\phi = \pm \SI{90}{\degree}$.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{dlatch}
    \caption{Acquisizione di un ciclo completo (frequenza 1 kHz) con Logic
    Analyzer dei segnali in ingresso ($D =$ DIO 0, $E =$ DIO 1) e in uscita
    ($Q =$ DIO 2, $\overline{Q} =$ DIO 3) dal D-Latch.
    \label{fig: dlatch}}
\end{figure}
\begin{figure}[htbp]
	\includegraphics[width=\textwidth]{latch2}
	\caption{Acquisizione con Logic dell'andamento temporale dei segnali in
	ingresso uscita dal D-Latch per $\phi = -\SI{90}{\degree}$.
	\label{fig: Log_DLATCH2}}
\end{figure}

Dalle \cref{fig: dlatch} e \cref{fig: Log_DLATCH2} si osserva come durante lo
stato basso di Enable il segnale in uscita rimanga costante rispetto a
variazioni del segnale in $D$, mentre quando
$E = 1 \implies Q(t + \Delta t) = D$ coerentemente con quanto previsto dalla
tabella di verità e come principio di funzionamento della memoria a 1 bit.

\subsection{Misura dei tempi di propagazione nelle transizioni di stato}
Si riescono a distinguere due diverse transizioni dei segnali in ingresso per
ciascun valore di sfasamento tra i due segnali di clock in $D$ ed $E$;
per $\phi = \SI{90}{\degree}$:
\begin{enumerate}
\item $D \coloneqq 0$, $E: 0 \to 1$ \label{item: Efall}
\item $D: 0 \to 1$, $E \coloneqq 1$. \label{item: Drise}

Mentre per $\phi = - \SI{90}{\degree} = 270 \; \si{\degree}$:
\item $D: 1 \to 0$, $E \coloneqq 1$ \label{item: Dfall}
\item $D \coloneqq 1$, $E: 0 \to 1$. \label{item: Erise}
\end{enumerate}

Si sono misurati i ritardi tra la transizione dei segnali in ingresso e i
corrispondenti cambiamenti di stato in uscita su scala dei tempi minima
($\SI{10}{n\s}$) con i cursori dalle acquisizioni con Logic Analyzer e per
riconferma anche con l'oscilloscopio da banco (a cui associamo come
incertezza il contributo dato dalle specifiche del datasheet, tenendo conto
dell'instabilità e dello spessore delle tracce sullo schermo). Riportiamo
di seguito e nella \cref{fig: Drise}, \cref{fig: Drise_osc}, \cref{fig: Dfall}
e \cref{fig: Erise} i risultati ottenuti.
\begin{enumerate}
\item $t_{PHL} = 30 \pm 10 \; \si{n\s}$
\item $t_{PLH} = 20 \pm 10 \; \si{n\s}$

\item $t_{PHL} = 40 \pm 10 \; \si{n\s}$
\item $t_{PLH} = 30 \pm 10 \; \si{n\s}$
\end{enumerate}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{dlatch_Drise}
    \caption{Acquisizione del Logic Analyzer durante la transizione
    \ref{item: Drise} del D-Latch \label{fig: Drise}}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{dlatch_Drise}
    \caption{Acquisizione da oscilloscopio digitale della transizione
    \ref{item: Drise} del D-Latch \label{fig: Drise_osc}}
    \includegraphics[width=\textwidth]{dlatch_Dfall40}
    \caption{Acquisizione del Logic Analyzer durante la transizione
    \ref{item: Dfall} del D-Latch \label{fig: Dfall}}
    \includegraphics[width=\textwidth]{dlatch_Erise}
    \caption{Acquisizione del Logic Analyzer durante la transizione
    \ref{item: Erise} del D-Latch \label{fig: Erise}}
\end{figure}

Il massimo ritardo indotto si è trovato in corrispondenza della transizione
\ref{item: Dfall} dell'input $D$ da alto a basso (con i cursori
dell'oscilloscopio $t_{PHL} = 35 \pm 2 \; \si{n\s}$) mentre il minimo per la
\ref{item: Drise} (con oscilloscopio $t_{PLH} = 11 \pm 1 \; \si{n\s}$).

Dalle specifiche del DS si trova che i tempi di propagazione tipici e massimi
per una singola porta NAND sono:
\begin{table}[htbp]
\centering
\begin{tabular}{cccc}
	& typ & max & [units] \\
    $t\ped{PLH}$ & $11$ & $22$ & \si{n\s} \\
    $t\ped{PHL}$ & $7$ & $15$ & \si{n\s}
\end{tabular}
\end{table}
da cui vediamo che le nostre misure dei ritardi accumulati tra uscita e
ingresso del circuito sono compatibili con i tempi necessari per il numero di
porte NAND che devono commutare per il cambiamento di stato del D-Latch.

%=======================
\section{Shift-register con edge-triggered D-Flip Flop}
\subsection{Costruzione del circuito}
Si vuole ora costruire uno Shift Register a 4 bit a partire da due integrati
della serie SN74LS74 (Dual Positive-Edge-Triggered Flip-Flops), secondo lo
schema riportato in \cref{fig: schem_shift} e verificarne il funzionamento.
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{schem_shift}
	\caption{\label{fig: schem_shift}}
\end{figure}

\subsection{Verifica della sincronia delle uscite rispetto a PRESET}
Una volta controllato che le uscite $Q_0$, $Q_1$, $Q_2$ e $Q_4$ fossero nello
stato $0000$, abbiamo utilizzato la funzione StaticIO per pilotare il PRESET
(ingresso PRE-BUTTON di \cref{fig: schem_shift}) tramite un pulsante inverso
(di tipo pressed$ = 0$ e released$ = 1$).
Dunque si è acquisito con Logic Analyzer l'andamento temporale dei 4 segnali
in uscita con condizione di trigger coincidente alla pressione del pulsante.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.trans}
	\caption{Acquisizione con Logic dei segnali in PRE-BUTTON le 4 uscite dal
	registro a scorrimento pilotato dall'ingresso di PRESET
	\label{fig: Shift_reg_trans}}
\end{figure}

Dalla \cref{fig: Shift_reg_trans} vediamo che le commutazioni delle
uscite avvengono allo stesso tempo, dopo un $\Delta t = 40 \si{n\s}$ a partire
dalla pressione del pulsante di preset le 4 uscite raggiungono lo stato $1111$.

Nella \cref{fig: reg_presync} si mette in evidenza come questo cambiamento di
stato avvenga indipendentemente dal segnale di clock in ingresso ai FF, da cui
si vede che l'ingresso di PRESET dei Flip-Flop è asincrono come atteso dalle
specifiche tecniche.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.b}
	\caption{Acquisizione con Logic dei segnali in PRE-BUTTON, CLOCK e
	$Q_{0, \ldots, 3}$ in uscita dal registro a scorrimento studiato
	\label{fig: reg_presync}}
\end{figure}

\subsection{Verifica del funzionamento tramite clock}\label{sbs: clock_reg}
Possiamo costruire una tabella di verità per il registro in funzione del tempo
(discreto) battuto dal periodo $T$ del clock:
\begin{table}[htbp]
\centering
\begin{tabular}{c|c}
\toprule
$Q_i(t = t')$ & $Q_i(t = t' + T)$\\
\midrule
\midrule
$Q_0$ & $Q_0'$ \\
$Q_1$ & $Q_0(t=t')$ \\
$Q_2$ & $Q_1(t=t') = Q_0(t = t' - T)$ \\
$Q_3$ & $Q_2(t=t') = Q_0(t = t'- 2T)$ \\
\bottomrule
\end{tabular}
\caption{Tabella "di verità" di un registro a scorrimento, in cui $Q_0'$ è il
valore che viene inviato durante il fronte di salita $t'$ del clock tramite
il $D$-SWITCH
\label{tab: S-register}}
\end{table}

Nel caso in cui il pulsante di PRESET inizializzi tutte le uscite a 1, e il
D-Switch sia impostato (sempre con StaticIO) al valore $Q_0' = 0$, la
\cref{tab: S-register} si traduce nelle commutazioni di stato previste dalla
\cref{tab: s-reg-truth}
\begin{table}[htbp]
	\centering
	\begin{tabular}{c|cccc}
	\toprule
	$t$	  &		$Q_0$	&	$Q_1$	& $Q_2$	&	$Q_3$  \\
	\midrule
	\midrule
		$t'$ 	&	$1$	&	$1$	&	$1$	&	$1$	\\
		$+T$	&	$0$	&	$1$	&	$1$	&	$1$	\\
		$+2T$	&	$0$	&	$0$	&	$1$	&	$1$	\\
		$+3T$	&	$0$	&	$0$	&	$0$	&	$1$	\\
		$+4T$	&	$0$	&	$0$	&	$0$	&	$0$	\\		
	\bottomrule
	\end{tabular}
\caption{Sequenza di transizioni che si osservano a partire da quando viene
premuto il pulsante di PRESET ($t'$) lasciando a livello basso il $D$-SWITCH
del registro a scorrimento. \label{tab: s-reg-truth}}
\end{table}

Per verificare il corretto funzionamento del circuito si pilota il registro
con un segnale di clock di frequenza $f = \SI{1}{\Hz}$ e si fa ancora uso di
Logic per acquisire gli andamenti nel tempo dei valori assunti dalle uscite.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.c}
	\caption{Acquisizione con Logic dei segnali in uscita da un registro a
	scorrimento di 4 bit come illustrato in \cref{sbs: clock_reg}
	\label{fig: Shift_reg_clock}}
\end{figure}
Dalla \cref{fig: Shift_reg_clock} si verifica come atteso che dopo 3 periodi
di clock (3 secondi) a partire da quando l'uscita $Q_0 = 0$, le 4 uscite
diventano (e si mantengono costanti nel tempo visto che il D-Switch rimane
fisso a 0) tutte quante basse.

Da questo si intuisce che collegando l'uscita (NOT) $Q_3$ all'ingresso
$D$-switch, possiamo generare una sequenza periodica/costruire un contatore
con modulo.

\subsection{Prevalenza tra gli ingressi D-switch e PRESET}
Utilizzando allo stesso tempo gli ingressi $D$-switch e PRESET del registro
si vede che è l'ultimo a pilotare il segnale in uscita, dal momento che PRESET
è asincrono (indipendente dalla salita del clock). Questo risulta consistente
con la regola generale per cui le architetture asincrone prendono la precedenza
sulle istruzioni sincrone. 

\subsection{Twisted-ring Johnson counter}
Dopo aver reimpostato il registro nello stato $Q_{i=0,\ldots, 3} = 0$, si
collega l'uscita $\overline{Q_3}$ all'ingresso $D$ del primo Flip-Flop e si
invia un clock di frequenza pari $f\ped{clk} = \SI{1}{k\Hz}$ all'ingresso del
circuito. Si riporta in \cref{fig: Shift_reg_seq} l'acquisizione con Logic
Analyzer dei segnali di clock e dei 4 output in funzione del tempo.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{3.e}
	\caption{Acquisizione con Logic dei segnali in uscita dal registro a
	scorrimento con l'ultima uscita negata collegata all'ingresso del primo FF.
	\label{fig: Shift_reg_seq}}
\end{figure}

Da questa vediamo che in ogni uscita $Q_i$ si ha un'onda quadra con frequenza
$f = f\ped{clk}/8$, ciascuna traslata temporalmente di un periodo di clock
rispetto alla $Q_{i-1}$ precedente; per cui nel registro osserviamo la
sequenza atomica $00001111$ ripetersi ogni $8$ cicli di clock.

Questo è dovuto al fatto che nel registro ora scorre in modo ciclico la
concatenazione dello stato iniziale degli output e del suo negato (tramite
il collegamento ad anello $\overline{Q_3} \to Q_0$).
Supponendo infatti che nel circuito siano collegati ad anello $n$
edge-triggered Flip-Flop, in una qualsiasi delle uscite del twisted-ring
Johnson counter ci si aspetta di trovare un clock di frequenza divisa di un
fattore $2n$.

%=======================
\section{Generatore di sequenze pseudo-casuali}
\subsection{Costruzione del circuito}
Si vuole ora costruire un generatore di sequenze pseudo-casuali a 4 bit
utilizzando lo shift register studiato in precedenza e una porta XOR (dal chip
integrato SN74LS86 Quad XOR Gate).
La schematica del circuito che utilizzeremo è riportata in figura
\cref{fig: schem_gen}.
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{schem_gen}
	\captionof{figure}{\label{fig: schem_gen}}
\end{figure}

\subsection{Analisi e verifica del funzionamento}
Dopo aver montato il circuito si inizializzano tutti Flip-Flop a 1, si invia
un segnale di clock a 10 kHz, sempre collegando gli output $Q_{0,\ldots, 3}$
ai canali del Logic Analyzer per verificarne il funzionamento.

Poiché il registro costruito ha memoria di $n = 4$ bit, dalla teoria ci
aspettiamo che la sequenza si ripeta dopo $2^4 = 16$ eventi al massimo,
condizione che si ottiene utilizzando come TAP (i.e. segnali in ingresso alla
porta XOR, la cui uscita è inviata all'ingresso $D = Q_0$ del primo FF) gli
output $Q_2$ (o $Q_0$) e $Q_3$.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b}
	\caption{Acquisizione temporale con Logic del bus in uscita dal generatore
	di sequenze psudo-casuale descritto in \cref{fig: schem_gen}
	\label{fig: TAP_23}}
\end{figure}

\begin{table}[htbp]
\centering
\begin{tabular}{cccc}
\toprule
$Q_0$ & $Q_1$ & $Q_2$ & $Q_3$ \\
\midrule
\midrule
1 & 1 & 1 & 1 \\
0 & 1 & 1 & 1 \\
0 & 0 & 1 & 1 \\
0 & 0 & 0 & 1 \\
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
1 & 0 & 0 & 1 \\
1 & 1 & 0 & 0 \\
0 & 1 & 1 & 0 \\
1 & 0 & 1 & 1 \\
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0 \\
1 & 1 & 0 & 1 \\
1 & 1 & 1 & 0 \\
1 & 1 & 1 & 1 \\
\bottomrule
\end{tabular}
\caption{Sequenza pseudo-casuale attesa collegando come TAP alla porta XOR i
segnali $Q_2$ e $Q_3$ in uscita dal registro
\label{tab: pseudo}}
\end{table}
Dall'acquisizione riportata in \cref{fig: TAP_23} si osserva la sequenza
riportata in \cref{tab: pseudo} ripetersi ogni 16 periodi di clock in accordo
con le aspettative (prendendo come riferimento una qualsiasi uscita dello
shift-register, visto che la sequenza nelle altre uscite sarà la medesima, ma
sfasata lungo l'asse temporale di qualche ciclo di clock).

\subsection{Studio delle sequenze generabili con diverse condizioni iniziali}
Si provano quindi altre combinazioni di TAP, per verificare che la scelta di
$Q_2$ e $Q_3$ produca una sequenza più lunga rispetto alle altre possibili
configurazioni. Riportiamo in \cref{fig: TAP_10}, \cref{fig: TAP_21} e
\cref{fig: TAP_30} i risultati ottenuti con Logic Analyzer dell'AD2.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b_10}
	\caption{Acquisizione con Logic del bus in uscita dal generatore di sequenze
	pseudo-casuali con TAP sulle uscite $Q_0$ e $Q_1$; la sequenza si ripete ogni
	4 cicli di clock.
	\label{fig: TAP_10}}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b_21}
	\caption{Acquisizione con Logic del bus in uscita dal generatore di sequenze
	pseudo-casuali con TAP sulle uscite $Q_2$ e $Q_1$; la sequenza si ripete ogni
	8 cicli di clock.
	\label{fig: TAP_21}}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{4.b_30}
	\caption{Acquisizione con Logic del bus in uscita dal generatore di sequenze
	pseudo-casuali con TAP sulle uscite La$Q_0$ e $Q_3$, la sequenza è massimale
	(si ripete ogni $2^n = 16$ cicli di clock).
	\label{fig: TAP_30}}
\end{figure}

%=======================
\section{Divisori di frequenza con contatori binari}
\subsection{Costruzione del circuito}
Si intende costruire un divisore di frequenza a partire da un contatore
binario a 4 bit (integrato SN74LS163 synchronous binary counter with
synchronous clear/load) secondo lo schema riportato in
\cref{fig: schem_counter}. 
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{schem_con}
	\caption{\label{fig: schem_counter}}
\end{figure}

\subsection{Verifica del ciclo di funzionamento dei contatori}
Si vuole innanzitutto verificarne il funzionamento.

Dopo aver montato il circuito utilizziamo la funzione Pattern di Waveform per inviare un segnale di clock di frequenza pari a 10 kHz al pin di clock (CLK) del contatore, e utilizzeremo Logic per acquisire le uscite $Q_0$->$Q_3$.
Essendo un contatore a 4 bit, ci si aspetta che il Bus conti dallo stato 0000 (0 in decimale) fino allo stato 1111 (15 in decimale).
Per questo motivo utilizzeremo un formato di Bus esadecimale per verificare che il circuito generi tutti gli stati possibili (0->F).
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.b}
	\caption{Acquisizione temporale con Logic del bus in uscita dal contatore, con frequenza di clock pari a 10 kHz \label{fig: Count_Clock}}
\end{figure}
Dalla \cref{fig: Count_Clock} si può notare che il comportamento del circuito è come atteso, e che gli stati del bus in uscita comprendono tutti i valori in ordine crescente della numerazione esadecimale 
\subsection{Verifica della divisione in frequenza}

Dato che il contatore incrementa di 1 ad ogni evento di clock, il bit di ordine n avrà come frequenza la metà di quella del bit di ordine n-1.
Avendo noi un BUS composto da 4 bit, ci si aspetta che le frequenze ottenute siano $\frac{f_clock}{2}$ (per il LSB),$\frac{f_clock}{4}$,$\frac{f_clock}{8}$ e $\frac{f_clock}{16}$ (per il MSB).
Sempre facendo riferimento all  \cref{fig: Count_Clock} si può notare come le uscite del contatore si comportino da divisori in frequenza: infatti i periodi che si trovano analizzando l'acquisizione sono 2 (LSB), 4, 8 e 16 (MSB) volte il periodo del clock.
\subsection{Transizione sincrona del contatore}
Utilizziamo quindi la funzione di trigger di Logic e la impostiamo in modo tale che l'acquisizione cominci quando il segnale presente in $Q_3$ cambia da 1 a 0 in modo da poter studiare gli eventuali ritardi delle singole uscite nella transizione F->0 e verificare il comportamento sincrono del contatore.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.d}
	\caption{Acquisizione temporale con Logic del bus in uscita dal contatore durante la transizione 15->0; dall'immagine possiamo notare il comportamento sincrono della commutazione delle uscite del contatore \label{fig: Count_150}}
\end{figure}
Dalla \cref{fig: Count_150} possiamo infatti vedere che la transizione è sincrona e il passaggio di stato 1->0 avviene contemporaneamente in ogni uscita.
\subsection{Divisore di frequenza 1/10; Contatore BCD}
Si vuole quindi realizzare un divisore in frequenza, che generi un segnale di periodo pari a 10 volte quello di clock: per farlo utilizzeremo il pin CLEAR del contatore, il quale quando viene inviato un segnale Low resetta il contatore allo stato 0000.
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{Draft1}
	\caption{Schematica utilizzata per il divisore per 10 di frequenza
	\label{schem: 10_div}}
\end{figure}
È quindi necessario che il contatore conti un totale di 10 stati e poi si resetti, per cui partendo dallo 0, dobbiamo imporre la condizione che arrivati allo stato 9, il contatore riceva l'impulso di Clear (che ricordiamo essere Active Low).
Per farlo utilizzeremo una porta NAND (utilizzando l'integrato SN74LS00) ai cui 2 ingressi invieremo il LSB e il MSB e invieremo l'uscita al pin di Clear. In questo modo, quando il contatore arriva a 9 (1001) il pin di Clear riceverà un segnale Low e il circuito si azzererà; pertanto la frequenza del segnale Clear sarà un decimo di quella di clock
Inoltre essendo il segnale di Clear sullo stato Low solamente quando il bus in uscita registra lo stato 1001, mi aspetterò un Duty Cycle pari al $90 \percent$
Si costruisce quindi il circuito presente in \cref{schem: 10_div}.
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.e}
	\caption{Acquisizione temporale con Logic del bus in uscita dal circuito che conta fino a 10; si può notare che il segnale in entrata nel pin Clear ha effettivamente periodo pari a 10 volte quello del clock \label{fig: Count_10th}}
\end{figure}
Come prima, si utilizza la funzione Logic per acquisire il Bus dei 4 bit in uscita, il clock e il bit di Clear.
Osservando l'acquisizione presente in \cref{fig: Count_10th}, possiamo concludere come da aspettative che il segnale presente su clear ha una frequenza pari a $\frac{f_{clock}}{10}$ e Duty Cycle pari al $90 \percent$.
\subsection{Divisore di frequenza programmabile con RCO}
Per concludere, si vuole costruire un divisore in frequenza programmabile:
per questo scopo utilizzeremo il bit RCO (Ripple Carry Output), la cui funzione è di generare un segnale H solo nel caso in cui il contatore abbia raggiunto lo stato massimo (1111) e il bit Load, che invece quando vale 0 sovrascrive lo stato del contatore in quello presente all'interno del bus di input. 
\begin{figure}[htbp]
\centering
	\includegraphics[width=0.6\textwidth]{Draft2}
	\caption{Schematica utilizzata per il divisore di frequenza programmabile}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.RCO}
	\caption{Acquisizione con Logic dei segnali del contatore per verificare il funzionamento del bit RCO}
\end{figure}
\subsection{Misura dei tempi caratteristici del divisore RCO}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0110_20ns}
	\caption{Acquisizione con logic dei segnali all'interno del circuito divisore di frequenza programmabile per un fondo scala dei tempi molto ristretto}
\end{figure}
\subsection{Analisi e verifica del comportamento del divisore RCO}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0000}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0000}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0010}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0010}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_0101}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 0101}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_1110}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 1110}
\end{figure}
\begin{figure}[htbp]
\centering
	\includegraphics[width=\textwidth]{5.f_1111}
	\caption{Acquisizione con Logic dei segnali all'interno del circuito divisore di frequenza programmabile, con sequenza di avvio 1111}
\end{figure}
%=======================
\section{Sintetizzatore musicale}
%TODO ? AMOGUSSSS AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
\iffalse
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣤⣤⣤⣤⣤⣶⣦⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡿⠛⠉⠙⠛⠛⠛⠛⠻⢿⣿⣷⣤⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⠋⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⠈⢻⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣸⣿⡏⠀⠀⠀⣠⣶⣾⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⠁⠀⠀⢰⣿⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣷⡄⠀
⠀⠀⣀⣤⣴⣶⣶⣿⡟⠀⠀⠀⢸⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣷⠀
⠀⢰⣿⡟⠋⠉⣹⣿⡇⠀⠀⠀⠘⣿⣿⣿⣿⣷⣦⣤⣤⣤⣶⣶⣶⣶⣿⣿⣿⠀
⠀⢸⣿⡇⠀⠀⣿⣿⡇⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠀
⠀⣸⣿⡇⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠉⠻⠿⣿⣿⣿⣿⡿⠿⠿⠛⢻⣿⡇⠀⠀
⠀⣿⣿⠁⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀
⠀⣿⣿⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀
⠀⣿⣿⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀
⠀⢿⣿⡆⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀
⠀⠸⣿⣧⡀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠃⠀⠀
⠀⠀⠛⢿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⣰⣿⣿⣷⣶⣶⣶⠶⠀⢠⣿⣿⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⣿⣿⡇⠀⣽⣿⡏⠁⠀ ⠀⢸⣿⡇⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⣿⣿⡇⠀⢹⣿⡆⠀⠀⠀ ⣸⣿⠇⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢿⣿⣦⣄⣀⣠⣴⣿⣿⠁⠀⠈⠻⣿⣿⣿⣿⡿⠏⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠛⠻⠿⠿⠿⠿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
\fi
%=======================
\section*{Conclusioni e commenti finali}
Si è riusciti a verificare il corretto funzionamento di circuiti logici
sequenziali di crescente complessità e svariate applicazioni (e.g.
crittografia, sistemi di controllo e misura) costruiti con porte NAND, XOR,
D-Latch e contatori sincroni.
In particolare sono stati realizzati e studiati un D-Latch, uno shift-register
con positive edge-triggered D-FF, un generatore di sequenze pseudocasuali e
alcuni tipi di divisore di frequenza con contatori binari.
Inoltre si è riusciti ad apprezzare l'effetto dei tempi di propagazione
delle porte sul loro comportamento, seppur in maniera limitata dalla bassa
risoluzione temporale dell'AD2.

%=======================
\section*{Dichiarazione}
I firmatari di questa relazione dichiarano che il contenuto della relazione \`e
originale, con misure effettuate dai membri del gruppo, e che tutti i firmatari
hanno contribuito alla elaborazione della relazione stessa.

\end{document}
