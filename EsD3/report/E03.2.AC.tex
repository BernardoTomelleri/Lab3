\documentclass[10pt, a4paper, italian]{article}
\input{../../latex/preamble}
\input{../../latex/math}
\usepackage{multicol}
\geometry{left=2cm, right=2cm, top=2cm, bottom=2cm}
\usepackage{colortbl}
\usepackage{diagbox}
\usepackage{tkz-graph}
\usetikzlibrary{automata, positioning, arrows}
\newenvironment{FSM}{
\begin{tikzpicture}
\tikzset{
->, % makes the edges directed
>=stealth', % makes the arrow heads bold
node distance=2cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={minimum size = 1cm, thick, fill=gray!10}, % sets the properties for each 'state' node
}
}{
\end{tikzpicture}
}

% indexes subsections with letters, sections with numbers (1.a, 1.b, ...)
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}

% lets graphicx know path where figures to be included are found
\graphicspath{{../figs/}}

\author{Gruppo 1.AC \\ Matteo Rossi, Bernardo Tomelleri}
\title{EsD3: Macchine a stati finiti: semafori e riconoscitore di fronti}
\begin{document}
\date{\today}
\maketitle

\section{Misura componenti dei circuiti}
Riportiamo per completezza il valore della tensione continua di
alimentazione per i circuiti integrati misurata con il multimetro
\[
V_{CC} = 4.99 \pm 0.03 \si{\V}
\]

e il valore di capacità del condensatore di disaccoppiamento che collega le
linee di alimentazione a massa (sempre misurato con il multimetro)
\[
C_d = 97 \pm 4 \; \si{n\F}
\]

%=======================
\section{Implementazione di un semaforo con circuiti integrati}\label{sec: IC}
\subsection{Diagramma a stati del semaforo}
Nel caso di semaforo ``abilitato'' i possibili output sono 3 e abbiamo quindi deciso di implementarli con 3 stati interni della macchina; nel caso di semaforo ``disabilitato'' i possibili output sono 2, ma possono essere ottenuti riutilizzando due degli stati precedenti e l'input ``enable'' tramite un'opportuno circuito combinatorio (\texttt{FSM} di Mealy).

Si è deciso di codificare in due bit di memoria i tre stati $ (00) $, $ (01) $ e $ (10) $ che corrispondono, quando $ E = 1 $ (abilitato), ai tre output ``verde'', ``verde-giallo'', ``rosso'' (che si susseguono in modo ciclico). Quando invece $ E = 0 $ (disabilitato) vengono usati solamente $ (00) $ e $ (01) $, che corrispondono agli output del semaforo ``spento'' e ``giallo''.

\begin{figure}[htbp]
\centering
\begin{FSM}
\tikzset{
    LabelStyle/.style = {
        rectangle, rounded corners, draw,
        minimum width = 1em,
    },
    EdgeStyle/.append style = {-stealth}
}

   \node[state with output] (V) {$V/Y^0$ \nodepart{lower} $00$};
   \node[state with output, right of=V, xshift=2cm] (VG)
   {$VG/Y^1$ \nodepart{lower} $01$};
   \node[state with output, right of=VG, xshift=2cm] (R)
   {$R$ \nodepart{lower} $10$};
   
   \Edge[label = E](V)(VG)
   \Edge[label = E](VG)(R)

\tikzset{EdgeStyle/.append style = {-stealth, bend right = 30}}
   \Edge[label = D](VG)(V)
   \Edge[label = D](V)(VG)

\tikzset{EdgeStyle/.append style = {bend right = 50}}
   \Edge[label = E](R)(V)

\tikzset{EdgeStyle/.append style = {bend left = 50}}
   \Edge[label = D](R)(V)
\end{FSM}
\end{figure}

\subsection{Codifica degli stati della macchina}
La scelta della codifica in termini di bit \`e riassunta nella tabella che segue: $Q_0$ e $Q_1$ rappresentano rispettivamente lo stato delle uscite del primo e del secondo flip-flop e $S$ \`e lo stato associato.
\begin{table}[htbp]
	\centering
	\begin{tabular}{cc|cc}
	\toprule
	$S_E$ &	$S_D$ & $Q_0$ &	$Q_1$ \\
	\midrule
	\midrule
	$Y^-$ & $V$  & $0$	&	$0$	\\
	$Y^+$ & $VG$ & $0$	&	$1$	\\
	 	  & $R$  & $1$	&	$0$	\\
	\bottomrule
	\end{tabular}
	\caption{codifica binaria degli stati del semaforo. \label{tab:bit}}
\end{table}

\subsection{Tabelle di verità}
Si nota in particolare dal diagramma degli stati che il segnale di input ENABLE modifica l'output in maniera asincrona, mentre dalla tabella di verità (\cref{tab:2bit}) si può distinguere come lo stato futuro dipenda da quello precedente sfruttando la sincronia del segnale di clock per incrementare il contatore.

\begin{table}[htbp]
    \centering
    \begin{tabular}{c|c|cc|cc|c}
     \multicolumn{1}{c||}{ENABLE}&\multicolumn{1}{c}{ }&\multicolumn{2}{c||}{current state} &\multicolumn{2}{c}{next state}\\
     \hline
         && Q$_1$ & Q$_0$ & D$_1$ & D$_0$ & \\
         \hline
        1 & G & 0 & 0 & 0 & 1 & GY\\
       & GY & 0 & 1 & 1 & 0 & R\\
       & R & 1 & 0 & 0 & 0 & G\\
        & ... & 1 & 1 & X & X & ...\\
        \hline
        0 & OFF & 0 & 0 & 0 & 1 & Y \\
        & Y & 0 & 1 & 0 & 0 & OFF \\
         & OFF & 1 & 0 & 0 & 0& OFF \\
         &  ... & 1 & 1 & X & X & ...\\
    \end{tabular}
    \caption{Tabella di verità per il semaforo a 2 bit.}
    \label{tab:2bit}
\end{table}

Di conseguenza, è possibile associare agli output led G, Y, R una corrispondenza in termini di bit secondo la logica:
\begin{itemize}
    \item Q$_0$ = 1 $\longrightarrow$ led giallo acceso (Y)
    \item Q$_1$ = 0 (o equivalentemente: $\overline{Q_1}$ = 1) $\longrightarrow$ led verde acceso (G)
    \item Q$_1$ = 1 $\longrightarrow$ led rosso acceso (R)
\end{itemize}
tale logica è sempre sottomessa al segnale di ENABLE, che consente che i led verde e rosso si possano accendere effettivamente. \\

Questa codifica è quella sfruttata per la costruzione vera e propria del circuito collegando i led alle uscite dei Flip-Flop (ad esempio: led giallo in serie a Q$_0$). \\

Per la precisione, dal momento che l'accensione dei led verde e rosso è consentita solo quando ENABLE = 1, si possono utilizzare due porte AND per definire
\begin{itemize}
    \item $\overline{Q_1} \cdot E \longrightarrow$ led verde acceso (G)
    \item $Q_1 \cdot E \longrightarrow$ led rosso acceso (R)
\end{itemize}

\paragraph{AND-gate per led rosso}
Si potrebbe usare una porta AND per rendere l'attivazione del led rosso dipendente dal segnale di ENABLE. Da \cref{tab:2bit} infatti si nota che l'unica differenza di funzionamento si avrebbe durante la transizione di ENABLE: 1 $\rightarrow$ 0. In questo caso, lo spegnimento diventerebbe asincrono col segnale di clock anziché sincrono.

\subsection{Mappe di Karnaugh e logica combinatoria}
Le seguenti tabelle di Karnaugh aiutano a derivare le funzioni logiche degli stati futuri in dipendenza da quelli correnti: \\

\begin{minipage}{0.5\textwidth}
    \centering
    \begin{tabular}{c||c|c|c|c}
        \backslashbox{E}{Q$_1$Q$_0$} & 00 & 01 & 11 & 10\\
        \hline
        \hline
        0 & 0 & 0 & X & 0\\
        \hline
        1 & 0 & \cellcolor[HTML]{FF9999}1 & \cellcolor[HTML]{FF9999}X & 0\\
    \end{tabular}
    %\captionof{table}{Tabella di Karnaugh}
    \label{k1}\\
    \hfill \\
    $D_1=E \cdot Q_0$
\end{minipage}
\begin{minipage}{0.5\textwidth}
    \centering
    \begin{tabular}{c||c|c|c|c}
        \backslashbox{E}{Q$_1$Q$_0$} & 00 & 01 & 11 & 10\\
        \hline
        \hline
        0 & \cellcolor[HTML]{FF9999}1 & 0 & X & 0\\
        \hline
        1 & \cellcolor[HTML]{FF9999}1 & 0 & X & 0\\
    \end{tabular}
    %\captionof{table}{Tabella di Karnaugh}
    \label{k2}\\
   \hfill \\
    $D_0=\overline{Q_0}\cdot \overline{Q_1}$
\end{minipage}

\subsection{Costruzione del circuito}
Si è assemblato il circuito riportato in ~\cref{schm: semf} e si
sono collegati i pin \texttt{preset} e \texttt{clear} dei D-FF a
$V_{CC}$ per evitare reset o clear spuri.
\begin{figure}[htbp]
    \centering
    \begin{circuitikz}
    \tikzset{flipflop D/.style={flipflop,
    flipflop def={t1=$D_0$, t6=$Q_0$, c3=1, t4=\ctikztextnot{$Q_0$}}},
	}
        \def\andScale{0.7};
        \def\crossup{-1};
        \def\mez{0.5}
        \def\andskip{2}

        % componenti
        %% flip flop
        \draw (0,0) node[flipflop D] (ffSinistra) {};
		\tikzset{flipflop D/.style={flipflop,
		flipflop def={t1=$D_1$, t6=$Q_1$, c3=1, t4=\ctikztextnot{$Q_1$}}},
		}
        \draw (5,0) node[flipflop D] (ffDestra) {};

        %% and
        \node (andSinistra) at (-2, |- ffSinistra.pin 1) [and port, scale=\andScale] {};
        \node (andDestra) at (3, |- ffSinistra.pin 1) [and port, scale=\andScale] {};
        \node [and port, scale=\andScale] (andSopra) at (5,4) {};

        % per i crossing
        \node at ($ (ffSinistra.pin 4) + (\mez,0) $) (ancilla) {};

        %% led
        \node[label=north:G] (G) at ($ (andSopra.out) + (1.7,0) $) {};
        \node[label=north west:Y] (Y) at ($ (G) + (0,-0.7) $) {};
        \node[label=south:R] (R) at ($ (G) + (0,-1.4) $) {};

        % input
        \node (E) at ($ (andSopra.in 1) + (-9,0) $) {$ E $};
        \node (CLK) at ($ (E)+(0,-7) $) {CLK};

        % fili
        %% clock
        \draw (CLK) -| (ffDestra.pin 3);
        \draw (ffSinistra.pin 3) -- (ffSinistra.pin 3 |-, |- CLK);

        % and e ff
        \draw (andSinistra.out) -- (ffSinistra.pin 1);
        \draw (andDestra.out) -- (ffDestra.pin 1);
        \draw (E) -- (andSopra.in 1);
        \draw (ffSinistra.pin 4) -- ++ (\mez,0) |- (andSopra.in 2);
        \draw (andSinistra.in 2) -| (-3.5, |- E);
        \draw (andDestra.in 1) --
        ($ (ffSinistra.pin 4 |-, |- andDestra.in 1) + (\mez,0) $) node[circ]{};
        %% and crossing
        \node at (ffSinistra.pin 4 |-, \andskip) [jump crossing] (X1) {};
        \node at (ancilla |-, \andskip) [jump crossing] (X2) {};
        \draw (andSinistra.in 1) |- (X1.west);
        \draw (X1.east) -- (X2.west);
        \draw (X2.east) -- (ffDestra.pin 6 |-, \andskip) node[circ]{};
        %% cancro del crossing pt 2
        \node at ($ (ffDestra.pin 3) + (0,\crossup) $) [jump crossing] (X) {};
        \draw (ffDestra.pin 4) |- (X.east);
        \draw (X.west) -| (andDestra.in 2);

        %% led
        \draw (10,-2.5) node[eground](gnd){};
        \draw (andSopra.out) -| (G) --++ (-0.2,0) to
        [/tikz/circuitikz/bipoles/length=1cm,empty led, fill=green] ++ (1.5,0)
        to[/tikz/circuitikz/bipoles/length=1cm, R,l=\SI{1}{\kilo\ohm}]
        ++ (1.5,0) -| (gnd);
        
        \draw (ffDestra.pin 6) |- (Y) --++ (-0.2,0)
        to [/tikz/circuitikz/bipoles/length=1cm,empty led, fill=yellow]
        ++ (1.5,0) to[/tikz/circuitikz/bipoles/length=1cm, R,l=\SI{1}{\kilo\ohm}]
        ++ (1.5,0) -| (10, 3.3) node[circ]{};
        %% Q0 crossing
        \node at (ancilla |-, |- R) [jump crossing] (X1) {};
        \node at (ffDestra.pin 6 |-, |- R) [jump crossing] (X2) {};
        \draw (ffSinistra.pin 6) |- (X1.west);
        \draw (X1.east) -- (X2.west);
        \draw (X2.east) -- (R) --++ (-0.2,0)
        to[/tikz/circuitikz/bipoles/length=1cm, empty led, fill=red]
        ++ (1.5,0) to[/tikz/circuitikz/bipoles/length=1cm, R,a=\SI{1}{\kilo\ohm}]
        ++ (1.5,0) -| (10, 2.6) node[circ]{};
    \end{circuitikz}
    \caption{schema del semaforo Mealy con enable.
    \label{schm: semf}}
\end{figure}

Per studiarne il comportamento generiamo nei due pin DIO 0 (CLOCK) e DIO 1
(ENABLE) dell'AD2 due segnali di clock di frequenza $f = \SI{20}{\hertz}$ e
$\SI{2}{\hertz}$ agli ingressi CLK ed $E$ del circuito. 

\subsection{Analisi e verifica del funzionamento del circuito}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{traffic}
    \caption{Acquisizione di un ciclo completo (frequenza 1 kHz) con Logic
    Analyzer dei segnali in ingresso e in uscita dal semaforo.
    \label{fig: dlatch}}
\end{figure}

%=======================
\section{Implementazione software della logica combinatoria con AD2/ROM}
\subsection{Costruzione del circuito}

\subsection{Implementazione delle tabelle di verità in ROM}

\subsection{Verifica del funzionamento del circuito}

\subsection{Variante svizzera del semaforo ROM}

%=======================
\section{Implementazione in software dei semafori con MCU (Arduino)}
\subsection{Collegamento LED semaforo alle uscite}

\subsection{Definizione interruttore di Enable}

\subsection{Implementazione del codice per la FSM}

\subsection{Versione svizzera del semaforo con Enable via Arduino}

%=======================
\section{Falling-edge detector}
\subsection{Progettazione FSM e costruzione dei circuiti}
Si vuole realizzare una FSM che riceve uno stream di bit su una linea di
ingresso e che accende un LED tutte le volte che si presenta un fronte di
discesa secondo il modello di Moore e secondo quello di Mealy.
\begin{figure}[htbp]
\centering
\begin{FSM}
\tikzset{node distance = 4cm, on grid, auto
}
\node (H) [state with output] {HIGH \nodepart{lower} $11$};
\node (C) [state with output, right of = H] {EDGE \nodepart{lower} $10$};
\node (L) [state with output, right of = C] {LOW \nodepart{lower} $00$};
 
\path [-stealth, thick]
	(H) edge [loop left]  node {IN=1}()
    (H) edge [bend left] node[above] {IN=0} (C)
    (C) edge [bend left] node[above] {IN=1} (H)
    (C) edge [bend left] node[above] {IN=0} (L)
    (L) edge [bend left] node {IN=1} (H)
    (L) edge [loop right]  node {IN=0}();
\end{FSM}
\caption{Edge detector FSM di Moore
\label{diag: edgeMoore}}
\end{figure}

\begin{figure}[htbp]
\centering
\begin{FSM}
\tikzset{node distance = 4cm, on grid, auto
}
\node (H) [state] {HIGH};
\node (L) [state, right of = H] {LOW};
 
\path [-stealth, thick]
	(H) edge [loop left]  node {IN$=1$ (OUT$=0$)}()
    (H) edge [bend left] node[above] {IN$=0$ (OUT$=1$)} (L)
    (L) edge [bend left] node {IN$=1$ (OUT$=0$)} (H)
    (L) edge [loop right]  node {IN$=0$ (OUT$=0$)}();
\end{FSM}
\caption{Edge detector FSM di Mealy
\label{diag: edgeMealy}}
\end{figure}

\begin{table}[htbp]
	\centering
	\begin{tabular}{cc|c}
	\toprule
	$D$ = IN & $Q$ & OUT \\
	\midrule
	\midrule
	$0$  & $0$	& $0$ \\
	$0$  & $1$	& $1$ \\
	$1$  & $0$	& $0$ \\
	$1$  & $1$  & $0$ \\
	\bottomrule
	\end{tabular}
	\caption{codifica binaria degli stati del detector di Mealy.
	$D$ = IN; OUT = $\overline{\text{IN}} \cdot Q$
	\label{tab: bitMealy}}
\end{table}

\subsection{Definizione dello stream di bit casuali in ingresso}
Con la funzione Patterns di Waveform si invia un segnale di clock di
frequenza $f\ped{clk} = \SI{1}{k\Hz}$ al pin (CLK) del contatore e si
acquisiscono i segnali in uscita con la funzione Logic
dello stesso.

\subsection{Verifica del funzionamento e analisi della temporizzazione}


%=======================
\section*{Conclusioni e commenti finali}
Si è riusciti a verificare il corretto funzionamento di circuiti logici
sequenziali di crescente complessità e svariate applicazioni (e.g., sistemi di
controllo e misura) costruiti con porte NOT, NAND, XOR, D-Latch e contatori
sincroni.
In particolare sono stati realizzati e studiati un D-Latch, uno shift-register
con positive edge-triggered D-FF, un generatore di sequenze pseudocasuali e
alcuni tipi di divisore di frequenza con contatori binari.
Inoltre si è riusciti ad apprezzare l'effetto dei tempi di propagazione
delle porte sul loro comportamento, seppur in maniera limitata dalla bassa
risoluzione temporale dell'AD2.

%=======================
\section*{Dichiarazione}
I firmatari di questa relazione dichiarano che il contenuto della relazione \`e
originale, con misure effettuate dai membri del gruppo, e che tutti i firmatari
hanno contribuito alla elaborazione della relazione stessa.

\end{document}
